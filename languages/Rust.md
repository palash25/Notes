## Installation

Rust can be installed through `rusetup` a CLI to manage Rust versions and
associated tools.

To install rust download and run the following shell script:

```
$ curl https://sh.rustup.rs -sSf | sh
```

## Update

```
$ rustup update
```

## Uninstall

```
$ rustup self uninstall
```
### Hello World

Write a file `main.rs` for word separators in filenames use underscores.

```rust
fn main() {
    println!("Hello world");
}
```

**Compile and Run**

```
$ rustc main.rs
$ ./main
```
Rust is an ahead-of-time compiled language, which means that one can compile a
program, give the executable to someone else, and they can run it even without
having Rust installed.

## Rust Program: Anatomy

- The main function is the first one to run for every executable rust program.
- Indentation uses 4 spaces (not tabs).
- Function calls with `!` at the end like the `println!` in the above example
  means its calling a Rust macro. Normal function calls don't include `!`.
- Semicolons are used to indicate end of expressions.


## Cargo

Cargo is used for the following tasks in rust projects:
- as a package manager
- as a build system
- downloads and builds the project dependencies

### Creating a project with Cargo

```
$ cargo new hello_cargo --bin
$ cd hello_cargo
```

This creates a new executable in the current directory from which the command
was run from named `hello_cargo`.

The `--bin` argument creates a new binary by the name `hello_cargo`. A project
directory with the same name is also with an src directory and a config file.

The config file `Cargo.toml` contains the project metadata.

A code package in rust is called a *crate*. All the logic of a crate should
reside in the `src` directory.

To build the project run `cargo build` from the project directory. This will
create an executable in the folder `target/debug/hello_cargo`. This command also
creates a `Cargo.lock` at the project root to keep a track of the versions of
all the dependencies used just like a `pip.lock` file.

Then run `./target/debug/hello_cargo` to execute the code.

To compile and run the binary in one go use `cargo run`.

`cargo check` to only compile the code without producing any binaries.

`cargo build --release` when the project is ready for realease. This will
generate the executable in the `target/release` directory. This binary will be
created with optimizations to make the rust code run faster.

## Rust Basics

- To include packages from the stdlib use `use std::io;`. This will include the
  io package from the standard library to be used in your program.
- `let` keyword can be used to create variables. For e.g. `let foo = bar;`
  creates a variable `foo` (immutable by default) and binds it to a value `bar`.
- `mut` keyword can be used before variable names to make them mutable. E.g.
  `let mut a = b;`
- For comments we can use `//`
- Variables can be assigned to different types. Like `let mut v = String::new()`
  This calls the `new` function of type `String` to return a new instance of
  string. `::new` means `new` is a function associated with the type `String`
- Example of using stdlib methods provided we have declared `io` in the scope of
  the program using `use std::io`:
  ```rust
  io::stdin().read_line(&mut v)
      .expect("Failed to read line");
  ```
  `stdin` function returns an instance of `std::io::Stdin` which is a handle for
  user input. `read_line` is a method on the standard input handle to get the
  user input and store it as a string. `&mut` is a reference to a particular
  value so that it can be used throughout the code without the need to copy that
  value into the memory everytime it is used. The argument is mutable so that
  the `read_line` method can change the value of the string value and store the
  user input in it.
  `read_line` in this case returns `io:Result` which is an enum with two
  *variants* (fixed set of values that enums contain) `Ok` and `Err`.
  `io::Result` has an `expect` method that displays the message provided if it
  has the variant `Err`.
- *Placeholders:*
  ```rust
  let x = 5;
  let y = 10;

  println!("x = {} and y = {}", x, y);
  ```

- All the crates in a project can be updated using `cargo update`.
- To use external dependencies write this line at the top of the file.
  `extern crate <crate-name>`
- To generate the documentation `cargo doc --open`. Opens up autogenerated docs
  in the browser.

## Better Error Handling
```rust
let guess: u32 = match guess.trim().parse() {
    Ok(num) => num,
    Err(_) => continue,
};
```
The underscore, `_`, is a catchall value; in this example, we’re saying we want to match all Err values, no matter what information they have inside them.

## Variable and Mutability

- Variables in rust are *immutable* by default. The compiler will complain if
  you try to assign values to a variable mutilple times
  ```
  error[E0384]: cannot assign twice to immutable variable `x`
  --> src/main.rs:4:5
     |
  2  |     let x = 5;
     |         - first assignment to `x`
  3  |     println!("The value of x is: {}", x);
  4  |     x = 6;
     |     ^^^^^ cannot assign twice to immutable variable
  ```
- Variables can be made mutable by adding `mut` in front of the variable name.

>
**Trade-offs:** In cases where you’re using large data structures, mutating an instance in place may be faster than copying and returning newly allocated instances. With smaller data structures, creating new instances and writing in a more functional programming style may be easier to think through, so lower performance might be a worthwhile penalty for gaining that clarity.

- **Constants:** Are immutable forever and cannot be used with `mut`. They are
  declared using `const` instead of `let` and must be type annotated.
  `const MAX_POINTS: u32 = 100_000;`
  Constants can be declared in any scope, including the global scope, which makes them useful for values that many parts of code need to know about. The last difference is that constants may be set only to a constant expression, not the result of a function call or any other value that could only be computed at runtime.

  > Constants are valid for the entire time a program runs, within the scope they were declared in, making them a useful choice for values in your application domain that multiple parts of the program might need to know about

### Shadowing

A new variable can be declared with the same name as that of a previous one. The
new variable then shadows the previous one and the value displayed is that of
most recent variable that shadowed its previous ones.
```rust
fn main() {
    let x = 5;

    let x = x + 1;

    let x = x * 2;

    println!("The value of x is: {}", x);
}
```
```
The value of x is: 12
```

> Shadowing is different than marking a variable as mut, because we’ll get a compile-time error if we accidentally try to reassign to this variable without using the let keyword.
By using let, we can perform a few transformations on a value but have the variable be immutable after those transformations have been completed.

The other difference between mut and shadowing is that because we’re effectively creating a new variable when we use the let keyword again, we can change the type of the value but reuse the same name. For e.g:
```rust
let spaces = "   ";
let spaces = spaces.len();
```
The second spaces is a new variable so can be assigned a different types
but the same thing with `mut` raises errors
```rust
let mut spaces = "   ";
spaces = spaces.len();
```

## Data Types

Rust has two data types `scalar` and `compound`. Since Rust is statically typed
in cases where many types are possible we need to add type annotations or else
the compiler might complain.

### Scalar
1. Integer: There are 10 kinds: i8, i16, i32, i64 & isize and their unsigned
   equivalents. The primary situation in which you’d use isize or usize is when indexing some sort of collection.
2. Floats: f32, f64
3. Bools: true and false
4. Chars

## Compounds

1. Tuples (multiple types of elements):
          ```rust
          fn main() {
              // declares a tuple `tup`
              let tup: (i32, f64, u8) = (500, 6.4, 1);

              // pattern matching to get individual tuple values (destructuring)
              let (x, y, z) = tup;

              let a = tup.2 // a = z

              println!("The value of y is: {} and z is: {}", y, z);
          }
          ```
   This :point_up: can also be done without the type annotations

2. Array (same types of element): The following gives an index out of bounds
          ```rust
          fn main() {
              let a = [1, 2, 3, 4, 5];
              let index = 10;

              let element = a[index];

              println!("The value of element is: {}", element);
          }

          ```

## Functions
- Functions are pervasive.
- Function names use snake case for naming.
- Functions can be defined before and after the `main` function.
- Type annotations are a must for functions parameters.
- Functions can return values and if there is no `return` statement the last
  expression's value is implicitly returned as the return value for that
  function.

  ```rust
  fn main() {
      let x = plus_one(5);

      println!("The value of x is: {}", x);
  }

  fn plus_one(x: i32) -> i32 {
      x + 1
  }
  ```

Note: In rust the assignment of a value doesn't return the assigned value. So
something like `x = y = 5` wouldn't be possible in Rust since statements don't
have return values.

## Expressions
```rust
fn main() {
    let x = 5;

    let y = {
        let x = 3;
        x + 1
    };

    println!("The value of y is: {}", y);
}

```

`The value of y is 4` (since the {} start a new scope with a different `x`)

An expression does not contain a `;` at the end which would make it a statement
Anything that returns a value is without a `;`


## Control Flow

- The condition in an if statement must result into a bool. This gives an error
  ```rust
  fn main() {
      let number = 3;

      if number {
        println!("number was three");
      }
  }
  ```
- Since `if`s are expressions they can be used on the RHS of `let`s
  ```rust
  let number = if condition {
        5
  } else {
        6
  };
  ```
  This on the other hand won't work. The type of number needs to be know at
  compile time.
  ```rust
  let number = if condition {
        5
  } else {
        "six"
  };
  ```
- There are 3 kinds of loops: `loop`, `while`, `for`. A `for` (more safe and
  concise than `while`s) loop looks like:
  ```rust
  fn main() {
      let a = [10, 20, 30, 40, 50];

      for element in a.iter() {
          println!("the value is: {}", element);
      }
  }
  ```

## Ownership

Instead of an automatic garbage collector or manually allocating and
de-allocating memory Rust uses a system of Ownership to assign memory to various

**Stack and Heap**: Data with unknown size that might change later is stored
on the heap and the rest on the stack.

**Rules:**
-Each value in Rust has a variable that’s called its owner.
-There can only be one owner at a time.
-When the owner goes out of scope, the value will be dropped.


The data types of the variables and arguments and the pointers to the heap
addresses are all stored on the stack but the actual data values are stored on
the heap.


```rust
let ims = "immutable string stored on the stack"

let mut s = String::from("hello");
s.push_str(", world!"); // push_str() appends a literal to a String
println!("{}", s); // This will print `hello, world!`
```

As soon as the variable (owner of a data value) goes out of scope the memory
allocated for that data is returned to the OS. At the `}` Rust calls a special
funcions `drop` to do this.

```rust
let x = 5; // bind the value 5 to x
let y = x; // make a copy of the value in x and bind it to y

let s1 = String::from("hello");
let s2 = s1;
```

The string however is made up of three parts: the ptr (that point to the
contents stored on the heap), the length (how many bytes the string is acquiring
right now) and the capacity (total memory that string receives from the OS)
(all 3 stored on the stack).

When we do `let s2 = s1;` we copy the length, capacity and ptr from the stack
and bind it to `s2` but not the actual string data on the heap.

*Besides this the original varialble is also invalidated before reaching its end
of scope as soon as the copy of the three data elements from s1 to s2 occurs.*
This is done because if both the variables point to the same scope once the
scope ends and drop function is called both the variables will try to delete the
same data on the heap leading to memory corruption. [This is known as the move
where s1 is moved to s2 and is no longer valid]

This way Rust automatically prevents making deep copies of your data which might
give us a performance gain.

**Making deliberate Deep Copy:**
```rust
let s1 = String::from("hello");
let s2 = s1.clone(); // the heap data is copied and neither of the variable is
                     // invalidated

println!("s1 = {}, s2 = {}", s1, s2);
```

#### Contradicting Example (Stack-only data copy)
```rust
let x = 5;
let y = x;

println!("x = {}, y = {}", x, y);
```

Without using `clone` `x` is still valid and hasn't moved to `y` because types
like integers are stored on the stack so making their copies is much quicker
as compared to making copies on the heap.

Types like integers have a special trait called `Copy` that prevent them from
getting moved but if the drop trait has been implemented for this type Rust won't
be able to annotate this type with `Copy`

```rust
fn main() {
    let s = String::from("hello");  // s comes into scope

    takes_ownership(s);             // s's value moves into the function...
                                    // ... and so is no longer valid here

    let x = 5;                      // x comes into scope

    makes_copy(x);                  // x would move into the function,
                                    // but i32 is Copy, so it’s okay to still
                                    // use x afterward

} // Here, x goes out of scope, then s. But because s's value was moved, nothing
  // special happens.

fn takes_ownership(some_string: String) { // some_string comes into scope
    println!("{}", some_string);
} // Here, some_string goes out of scope and `drop` is called. The backing
  // memory is freed.

fn makes_copy(some_integer: i32) { // some_integer comes into scope
    println!("{}", some_integer);
} // Here, some_integer goes out of scope. Nothing special happens.

```

Transferring Ownerships

```rust
fn main() {
    let s1 = gives_ownership();         // gives_ownership moves its return
                                        // value into s1

    let s2 = String::from("hello");     // s2 comes into scope

    let s3 = takes_and_gives_back(s2);  // s2 is moved into
                                        // takes_and_gives_back, which also
                                        // moves its return value into s3
} // Here, s3 goes out of scope and is dropped. s2 goes out of scope but was
  // moved, so nothing happens. s1 goes out of scope and is dropped.

fn gives_ownership() -> String {             // gives_ownership will move its
                                             // return value into the function
                                             // that calls it

    let some_string = String::from("hello"); // some_string comes into scope

    some_string                              // some_string is returned and
                                             // moves out to the calling
                                             // function.
}

// takes_and_gives_back will take a String and return one.
fn takes_and_gives_back(a_string: String) -> String { // a_string comes into
                                                      // scope

    a_string  // a_string is returned and moves out to the calling function
}
```

The above approach is a bit tedious because we have to transfer ownership and
then return it to the same function.

*To just pass the value without the ownership we can use references*

### References and Borrowing

```rust
fn main() {
    let s1 = String::from("hello");

    let len = calculate_length(&s1); // refers to the string but does not own it

    println!("The length of '{}' is {}.", s1, len);
}

fn calculate_length(s: &String) -> usize { // Borrowing
    s.len()
} // s goes out of scope but since it does not own s1 nothing happens
```

If references are used as function parameters it is called as *Borrowing*
**References are also immutable by default** This can be changed by doing
something like

```rust
fn main() {
    let mut s = String::from("hello");

    change(&mut s);
}

fn change(some_string: &mut String) {
    some_string.push_str(", world");
}
```

**Restriction:** Only one mutable reference can exist in a particular scope.

Not valid

```rust

let r1 = &mut s;
let r2 = &mut s;

```

This prevents data races which occur in one of the following situations:
- Two or more pointers access the same data at the same time.
- At least one of the pointers is being used to write to the data.
- There’s no mechanism being used to synchronize access to the data.

A workaround for this could be creating new scopes using `{}` to allow
multiple mutatable references.

```rust
// mutable and immutable references cannot be combined

let mut s = String::from("hello");

let r1 = &s; // no problem
let r2 = &s; // no problem
let r3 = &mut s; // BIG PROBLEM
```

It gives the following error.

`error[E0502]: cannot borrow `s` as mutable because it is also borrowed as
immutable`

### Dangling References

```rust
fn main() {
    let reference_to_nothing = dangle();
}

fn dangle() -> &String { // dangle returns a reference to a String

    let s = String::from("hello"); // s is a new String

    &s // we return a reference to the String, s
} // Here, s goes out of scope, and is dropped. Its memory goes away. Danger!


fn no_dangle() -> String {
    let s = String::from("hello");

    s
}
```
